package day01;
/*
 * 이름짓는 규칙과 변수 
 * Magic Number
 * 하드코딩 
 * 애거서 크리스티 
 * 추리소설의 10가지 원칙 중에 나와 있는 
 * "중국인 마술사를 등장 시키지 마라"
 * 추리소설의 트릭은 말이 되어야하지 
 * "사실 내가 살인을 저지르고 안 잡힌 이유는 내가 순간이동이 가능해서야!" >> 추리소설이 아니다 
 * 
 * 프로그래밍도 마찬가지 
 * 프로그래밍에는 magic number라는 애가 있다. 
 * 갑자기 튀어나온 숫자 
 * 갑자기 튀어나온 문자열(=스트링)값
 * 이런 애들을 우리가 magic number라고
 * 우리가 코딩할 때는 쉽지만 
 * 유지 보수 할 때는 어렵다. 
 * 
 * 왜냐하면 
 * 해당 값을 매번 변경이 있을 때 마다 찾아서 바꿔줘야하기 때문
 * 
 * 대표적인 예시 :
 * File file = new File("c:/index.index.txt");
 * 위의 코드에서 c:/index.index.txt 라고 적힌 부분이 바로 하드코딩(magic number)
 * 만약 파일 이름이 바뀌거나 위치가 바뀌면? 
 * 그럴 땐 우리가 직접 이 코드의 위치를 찾아서 " " 안에 있는 글자를 매번 직접 바꿔줘야한다!
 * 
 * 하드코딩의 장점 : 쉽다 
 * 하드코딩의 단점 : 유지보수가 어려워진다. 
 * 
 * TCS vs LCS
 * TCS : Tightly Coupled System > 단단히 결합된 시스템
 * LCD : Loosely Coupled System > 느슥히 결합된 시스템 
 * 
 * 하드코딩을 예방하려면 적극적인 변수와 상수를 활용하는게 중요하다 
 * 좀 극단적인 변수 상수 활용의 예를 보면
 * 심지어 PI = 3.11415... 등으로 절대 불변할 값들도 상수 선언해서 쓰는 개발자들도 있다. 
 * 
 * 이름 짓는 규칙 
 * 1. 여러 단어 일 때에는 무조건 낙타등 표기법(camel back notation) 사용 
 * 	예시 ) firstNumber, MemberController 
 * 	> 두번째 단어 이상의 단어 첫글자는 항상 대문자 
 * 2. 자바의 중요한 단어들인 예약어로는 이름으로 사용할 수 없다. 
 * 	이클립스에서 보라색으로 표시해줌 
 * 	만약 내가 어떤 이름으로 설정했는데 보라색으로 뜬다면 곧장 바꿔주면 된다.
 * 3. 특수문자, 한글 안됨(한글은 되긴 하지만 사용하지 말기)
 * 
 *  
 * 변수 이름 짓는 규칙
 * 1. 소문자로 시작 
 * 2. 명사
 * 예시 ) int firstNumber, Member member
 * 		ProductController productController
 * 
 * 상수 이름 짓는 규칙 
 * 1. 모든 글자를 다 대문자로 
 * 2. 여러 단어일 경우 단어 사이에는 _ 를 넣어준다. 
 * 예시) PI, UNIT_PRICE
 * 
 * 메소드 이름 짓는 규칙 
 * 1. 소문자로 시작
 * 2. 동사 
 * 예시 ) print(), search(), viewAll()
 * 
 * 클래스 이름 짓는 규칙 
 * 1. 대문자로 시작
 * 2. 명사 
 * 
 * 패키지 이름 짓는 규칙 
 * 사실 그 패키지에 모여있는 클래스들이 공통적으로 가진 이름 
 * 혹은 
 * 공통적인 기능부분을 
 * 1. 소문자 
 * 2. 명사로 적어주면 된다!
 * 예시 ) util >  개발에 도움이 되는 자바의 클래스들이 모여있다. 
 * 		controller > DB로 부터 전달받은 값을 웹으로 보내주는 클래스들이 있다. 
 * 
 * 변수 그리고 자료형 
 * 변수란, 특정 공간에 값을 넣고 
 * 해당 공간을 우리가 지칭한 이름으로 부르는 것 
 * 또한 그 특정 공간의 값은 필요로한다면 언제든지 바꿀 수 있다. 
 * 
 * 변수 선언 방법
 * 데이터타입 이름 
 * 
 * 
 * 내가 변수를 선언할 때에는 
 * 해당 공간이 어떠한 종류의 데이터만 받아들일 수 있는지 
 * 적어줘야한다. 
 * 이렇게 해당 공간의 데이터 성격을 적어주는 건
 * 데이터타입(자료형) 이라고 한다. 
 * 
 * 자료형은 크게 두가지
 * 기본형, 참조형
 * 
 * 기본형과 참조형의 차이는 
 * 각각의 세부 내용이 JVM의 어느 메모리에 선언이 되는지가 다르다. 
 * 
 * 기본형은 stack 메모리 영역에 선언 되고 
 * 해당 영역에 적혀있는 데이터타입과 맞는 실제 값이 들어가있다.
 * 
 * 참조형은 stack 메모리 영역에 선언 되는데 
 * 해당 영역에는 heap 메모리 주소값이 적혀져 있다. 
 * 즉 우리가 실제 값을 보려면 이 메모리 주소를 '참조' 해서
 * 찾아야하기 때문에 참조형이 된다. 
 * 
 * stack 메모리에 있는 모든 값들은 
 * 2진법 숫자로 변환된 값들이다. 
 * 
 * 기본형 데이터타입
 * 기본형 데이터 타입에는 총 8개의 자료형이 있다. 
 * 정수형 : byte, short, int, long
 * 실수형 : float, double
 * 논리형 : boolean 
 * 문자형 : char
 * 
 *  
 * 참조형 데이터타입
 * 참조형은 크게 3가지로 나뉜다. 
 * 클래스, 인터페이스, 배열 
 * 이 3개는 참조형 변수가 된다. 
 * 
 */
public class Ex02 {
	public static void main(String[] args) {
		// 기본형은 우리가 설정한 곳에 직접 값이 들어가 있다. 
		// 정수형 
		// 정수는 소수점이 없는 음수부터 양수 모두를 뜻함 
		/* byte : 8비트 -> -2의 7승 ~ 2의 7승 -1까지 
		 * short : 16비트 -> -2의 15승 ~ 2의 15승 -1까지
		 * int : 32비트 -> -2의 31승 ~ 2의 31승 -1까지 
		 * long : 64비트  -> -2의 63승 ~ 2의 63승 -1까지 
		 */
		
		/*
		 * 실수형 
		 * 실수란 소수점이 표현되는 숫자 
		 * float : 적은 자리수의 실수 
		 * double : 많은 자리수의 실수 
		 * 
		 */
		/*
		 * 문자형 
		 * ascii 코드 값에 맞춘 문자 1개 
		 * char : 7비트 
		 * 
		 */
		
		/*
		 * 논리형 
		 * 참거짓 2개의 값만 가진 1비트 
		 * boolean : true/ false
		 * 
		 */
		
		int number; // 이 number 안에 무슨 값이 들어가 있을까?
					// 당연히 모른다. 
					// C에서와는 다르게 자바에서는 변수를 초기화해야지만 사용 가능 
		number = 10; 
		System.out.println(number);
		// 변수 선언을 한 이상 자유롭게 사용 가능 
		System.out.println(number + 5);
		
		// 우리가 자료형 바꿈을 형변환(type casting)이라고 한다. 
		// 1. 암시적 형변환 (implicit type casting)
		//		암시적 형변환의 경우 
		// 		같은 종류이고 (정수, 실수등)
		//		더 큰 데이터 타입에 더 작은 데이터 타입을 옮겨 담을 때 발생 
		//		예시 ) number를 long형 변수에 넣을 때 
		long longVar = number; 
		
		// 2. 명시적 형변환 ( explicit type casting) 
		//		명시적 형변환의 경우에는 
		//		더 큰 데이터 타입을 더 작은 데이터타입에 옮겨 담을 때 발생 
		// 		이 때는 데이터가 '흘러 넘치더라도 ' 괜찮다고 명시적으로 말해줘야함 
		//		예시 ) number에 longVar의 값을 넣을 때 
		// number = longVar; >> Error
		//		명시적 형변환은 바꿀 값 앞에 ()를 넣고 그 안에 
		// 		바꿀 자료형을 적어준다 
		number = (int)longVar;
		//		단! overflow, underflow의 문제가 생길 수 있으니 주의 
		//		overflow : 해당 자료형이 표시할 수 있는 값의 최대값을 넘어(over)가면 발생 
		//		underflow : 해당 자료형이 표시할 수 있는 값의 최소값 아래로(under)가면 발생
		
		// 이 문제가 발생하는 이유는 
		// 컴퓨터의 자리수 표현이 맨 앞자리가 부호를 결정하기 때문 
		// 예를 들어 byte 형의 경우 
		// 0000 0000은 0
		// 0111 1111 은 127이지만 
		// 1000 0000은 128이 아닌 -128이다. 
		// 1000 0001은 얼마일까? -127
		// 음수 중의 최대값은? 
		// 1111 1111은 -1 
		// 그럼 1000 0000에서 1을 빼면? 
		// 그럼 0111 1111이 되고 
		// 127 이 된다. 
		
		System.out.println("오버플로우 ");
		byte myByte = 127;
		//System.out.println(myByte + 10); // 137 : 얘들이 알아서 int로 바꿔줌 
		System.out.println((byte)(myByte+10)); // -119
		
		System.out.println("언더플로우 ");
		System.out.println((byte)(myByte-300)); 
		// 127-255 >> -128
		// 127-255 -45 =-128-45
		// = -128-1-45 = 127 -44
		// = 83
		
		// 하지만 이제는 overflow와 underflow를 볼 일이 잘 없다. 
		// 왜 일까? 
		// 이제 자바에서는 정수를 보면 자동으로 int로 잡아주고 
		// 실수를 보면 double로 잡아준다.
		//longVar = 2147483648; //int의 범위를 벗어났다는 에러 
		longVar = Long.valueOf(2147483647); // 해당 숫자는 사실 int값을 벗어나지 않는 듯.. (에러가 안남) 추후 다시 확인할 것
		// valueOf > 클래스
		
		// 하지만 기본형 변수들 까리는 다른 종류더라도 type casting 가능 
		// 단, 명시적으로 
		
		// 문자형은 0 ~ 127 의 값마다 
		// 한 개의 글자가 있다. 
		char myChar = 'A';
		System.out.println((char)(myChar+32));
		//System.out.println((char)(65));
		// 더 큰 데이터타입에 산술연산자 와 더 작은 데이터타입이 연산되면? 
		// 그럼, 자바는 자동으로 더 큰 데이터 타입을 결과로 내놓는다. 
		// 왜냐? 더 큰 데이터타입을 더 작은 데이터타입으로 바꾸면 > 오버플로우나 언더플로우 문제가 생길 수 있기 때문 
		// 다라서 문제가 없는 더 작은 데이터타입을 더 큰 데이터타입으로 자동(암시적) 형변환해줌 
		
		
		// 정수 + 실수 는 자동으로 실수로 변환해서 출력 
		System.out.println(number + 0.1);
	}
}
