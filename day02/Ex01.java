package day02;
/*
 * 비트 연산자 
 * &, |, ^, ~, <<, >>, >>>
 * & : 두 비트의 같은 자리수가 1이면 1, 그 외에는 0 
 * | : 두 비트의 같은 자리수가 하나라도 1이면 1, 둘다 0일 때만 0 
 * ^(XOR) : 두 비트의 같은 자리수가 다르면 1 같으면 0 
 * ~ : 한 비트에 대해 해당 자리수의 값을 반대값으로 바꿔준다 ( 1 -> 0, 0 -> 1)
 * << : 비트를 오른쪽에 나온 숫자만큼 왼쪽으로 이동 
 * >> : 비트를 오른쪽에 나온 숫자만큼 오른쪽으로 이동 
 * >>> : 비트를 오른쪽에 나온 숫자만큼 오른쪽으로 이동하고 왼쪽에는 무조건 0을 붙인다. 
 *  
 */
public class Ex01 {

	public static void main(String[] args) {
		int number1 = 10; // 0x0000 1010
		int number2 = 21; // 0x0000 0101
	
		
		/*
		 * 자바에서는 굳이 머리를 싸매고 이진법 변환을 일일이 하지 않아도 
		 * 알아서 출력을 해준다 
		 * 어떻게? Integer.toBinaryString()을 사용해서!
		 */
		System.out.println(Integer.toBinaryString(number1));
		System.out.println(Integer.toBinaryString(number2));
		// 결과값은 String이다. 
		
		
		// 1. AND 연산
		// 0000 1010
		// 0001 0101 : 이 두 숫자에 대한 AND 연산을 해보자 
		// ----------
		// 0000 0000 : 따라서 결과 0 
		System.out.println(number1 & number2);
		
		// 2. OR 연산 
		// 0000 1010
		// 0001 0101
		// ----------
		// 0001 1111 : 따라서 결과 31 
		System.out.println(number1 | number2);
		
		// 3. XOR 연산 
		// 0000 1010
		// 0001 0101
		// ----------
		// 0001 1111 > 31
		System.out.println(number1 ^ number2);
		
		// 4. ~ 연산 (다 반대로 바꿔준다)
		// 0000 1010
		// ----------
		// 1111 0101 > 
		System.out.println(~number1);
		
		// 5. << 연산 (나온 숫자만큼 왼쪽으로 이동 : 오른쪽에 00을 붙이더라.. )
		// 0000 1010 << 2 
		// 00 1010 00 (오른쪽에 붙여준 만큼 왼쪽은 지운다 )
		// = 0010 1000 
		// 왼쪽 쉬프트 연산 생각해보면 사실 결과값 예상이 쉽다. 
		// 왜냐? 
		// 10진법으로 한번 생각해보자 
		// 숫자 6이 있고 걔를 왼쪽으로 2자리 옮기고 뒤에 0을 붙이면? 
		// 6 * 10 * 10 -> 600
		// 2진법은? 
		// 옮기는 자리수만큼 2를 곱해주면 된다. 
		System.out.println(number1 << 2);
		
		// 6. >> 연산 
		// 0000 1010 >> 2
		// 000000 1010 (왼쪽에 0 붙여준다) 
		// = 0000 0010
		System.out.println(number1 >> 2);
		// 그런데 오른쪽 이동은 한가지 특징이 있다. 
		// >> 의 경우에는 부호유지가 된다. 
		// 1000 1000 -> -128 + 8 -> -120 
		// 1000 1000 >> 2 의 경우에는 
		// 맨 앞자리가 1, 즉 - 라는 의미이므로 
		// 오른쪽 이동할 때 0 대신 1이 붙는다. 
		// 11 1000 1000 
		// = 11 1000 10
		// = 1110 0010 -> -128 + 64 + 32 + 2 : -30
		System.out.println(-120 >> 2);
		
		
		// 7. >>> 연산 
		// >>>의 경우에는 부호를 무시하고 무조건 0을 붙인다. 
		// 1000 1000 >>> 2 
		// 00 1000 1000
		// = 0010 0010 -> 1073741794
		// 왜? 
		// 0011 1111 1111 1111 1111 1111 1110 0010 >>> 2
		
		System.out.println(-120 >>> 2);
		
	}

}
